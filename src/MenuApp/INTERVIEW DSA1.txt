https://en.savefrom.net/1-youtube-video-downloader-357/?url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DunONNxYQjCE&utm_source=youtube.com&utm_medium=short_domains&utm_campaign=ssyoutube.com&a_ts=1664085522.695
https://en.savefrom.net/1-youtube-video-downloader-357/?url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DApqq6wgCv4o&utm_source=youtube.com&utm_medium=short_domains&utm_campaign=ssyoutube.com&a_ts=1664085527.297
https://en.savefrom.net/1-youtube-video-downloader-357/?url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DQ5Xen_Y7lUk&utm_source=youtube.com&utm_medium=short_domains&utm_campaign=ssyoutube.com&a_ts=1664085532.6


https://leetcode.ca/2019-01-25-1152-Analyze-User-Website-Visit-Pattern/
https://www.interviewbit.com/blog/median-of-two-sorted-arrays/
https://leetcode.com/problems/median-of-two-sorted-arrays/

https://my.newtonschool.co/playground/code/pxk94jumlk9n/

https://leetcode.com/problems/reorganize-string/
https://leetcode.com/problems/find-and-replace-pattern/
https://leetcode.com/problems/search-suggestions-system/

What are data structures?
What are algorithms?
https://leetcode.com/problems/binary-tree-level-order-traversal-ii/
https://leetcode.com/problems/binary-tree-maximum-path-sum/


[8:06 pm, 10/08/2022] shashank: 1. What is Array
2. Can we store different data types at a same time
3.  Some of the sorting technique names
4. Write a code to sort an int array use any of the Sorting technique and then write a code to find an element in it (inside sorted array)
5. Can we create HashMap with int,int instead of Integer,Integer
6. What is Difference between Integer and int
7. Write a code to find number of occurences of a String inside an array given using Hashing.
8. Print it using Entry and entrySet method
[8:06 pm, 10/08/2022] shashank: Mock Interview Questions:

1) WAP to find second largest number in array. 
Input : arr = {12,35,1,10,34}, Output : 34

Q. What is an array in Java? Types of arrays in java?
-Is it possible to declare array size as negative? why?
-What is the default value of the array?
-Various syntaxes of declaring arrays.
-What are sorting algorithms? Give time complexity of all.
-Which algorithm is not in place? why?
-Which algorithm do you prefer for the sorting elements?
-What is hashing algorithm? How does it work?
-What are different searching algorithms?
-What is Hash Collision?
-Difference between linear and binary search algorithms.
-Bubble sort
-WAP to reverse an array.
-Binary search

1) WAP to Implement the reverse of an array and take the input by user also discuss the Time Complexity of it.
2) WAP to Implement Bubble sort and discuss it's Time Complexity.
3) Find the non repeating element in the array.
4) Move the zeros to the end of the array.
5) Quicksort
6) Print all unique element of array
7) how to find the minimum "absolute difference" between adjacent elementsin circular array...
8) max min in array
9) Find the maximum pair sum in the given array.
10) Find all the elements which are occurring more than once in the given array.
11) Find the frequency of a given element in the given sorted array.	
12) Searching the element in the rotated array


1) What are arrays?
2) What is searching 
3) How many type of searching algorithm are there
4) what is sorting 
5) types of sorting algorithm
6) basic principle of bubble sort
7) basic principle of binary search
8) binary search time complexity
9) find the sum of all the odd numbers in array
10) find the largest number in array
11) implement binary search

1) What is hashing? what are hashmaps? Hashsets? implement them.
2) Write a program to print uniques characters from a string

1) How memory allocation takes places in arrays
2) what are the prototype function of array in Java
3) Which sorting algo is best one merge or quick sort and why
4) disadvantages of binary search
5) 2d array matrix of n*n then you need to output the spiral path of the 2d array

1) Find the maximum repeated element from the array, if multiple element have the same high frequency return a big number.
2) Sort the array in way all odd numbers came first in ascending order and all even numbers came in descending order
3) Find all pairs whose elements sum is equal to the target sum.

1) Given an integer array of 0's, 1's and 2's. Sort the array without using counts, hashmap. extra space and time complexity should be O(n).
2) given a rotated sorted array and target. Return the index of target in array and time complexity should be O(log(N))
3) Given an array of integer and target, return the pair of indexes which element sum is like target and time complexity should be at max O(Nlog(N))

1) Array and its types
2) Store array elements leaving the last 2 indices without any value stored. What will be printed when last 2 indices are accessed.
3) print index of the search element if it exist else print -1
4) sort the array in descending order

1) Given a sorted array of integers, find the index of a given target elements.
2) Given an array containing 0s and 1s, write an algo to sort the array in O(n).

1) Given an unsorted array of both negative and positive integer. the task is place all negative element at the end of array without changing the order of positive element and negative element.

1) Sort binary array of 0 and 1 in linear time and without using extra space.
2) Rearrange the string characters to left and digits to right while maintaining original order. 

1) Write a function that takes in an array of at least three integers and, without sorting the input array, returns a sorted array of the three largest integers in the input array.
2) Write a function that takes in an non empty array of integers and returns an array of the same length, where each element in the output array is equal to product of every other number in the input array.

1) Implement an algorithm, given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.

1) Find the count of distinct element in every subarray of size 'k'

1) Write a program to remove duplicate elements from  an array

1) time complexity of search in hashing
2) why time complexity of searching any element in hashing O(n)
3) How and values are going to work in hashing
4) how to create hash function
5) why we need hashing when we already have a linked list?

1) Given an array of size N containing only 0s, 1s, and 2s. Sort the array in ascending orders.
2) You are given an unsorted array with both positive and negative elements. You have to find the smallest positive number missing from the array.
input {2,3,7,6,8,-1,-10,15} output: 1





https://www.geeksforgeeks.org/maximum-product-subarray/
freecodecamp

https://practice.geeksforgeeks.org/problems/count-subarrays-with-equal-number-of-1s-and-0s-1587115620/1/?page=2&difficulty[]=1&category[]=Arrays&sortBy=submissions
https://practice.geeksforgeeks.org/problems/next-permutation5226/1/?page=2&difficulty[]=1&category[]=Arrays&sortBy=submissions
https://practice.geeksforgeeks.org/problems/replace-every-element-with-the-least-greater-element-on-its-right/1/?page=1&difficulty[]=2&category[]=Arrays&sortBy=submissions
https://practice.geeksforgeeks.org/problems/count-the-subarrays-having-product-less-than-k1708/1/?page=1&difficulty[]=2&category[]=Arrays&sortBy=submissions
https://practice.geeksforgeeks.org/problems/find-all-four-sum-numbers1732/1/?page=1&difficulty[]=1&category[]=Hash&sortBy=submissions
https://practice.geeksforgeeks.org/problems/minimum-insertions-to-make-two-arrays-equal/1/?page=1&difficulty[]=2&category[]=Hash&sortBy=submissions
https://practice.geeksforgeeks.org/problems/largest-rectangular-sub-matrix-whose-sum-is-0/1/?page=1&difficulty[]=2&category[]=Hash&sortBy=submissions
https://practice.geeksforgeeks.org/problems/find-k-th-smallest-element-in-given-n-ranges/1/?page=2&difficulty[]=1&category[]=Sorting&sortBy=submissions
https://practice.geeksforgeeks.org/problems/count-smaller-elements2214/1/?page=1&difficulty[]=2&category[]=Sorting&sortBy=submissions
https://practice.geeksforgeeks.org/problems/stack-permutations/1/?page=2&difficulty[]=1&category[]=Stack&sortBy=submissions
https://practice.geeksforgeeks.org/problems/reverse-a-stack/1/?page=2&difficulty[]=1&category[]=Stack&sortBy=submissions
https://practice.geeksforgeeks.org/problems/remove-k-digits/1/?page=1&difficulty[]=1&category[]=Stack&sortBy=submissions
https://practice.geeksforgeeks.org/problems/smallest-number-on-left3403/1/?page=1&difficulty[]=1&category[]=Stack&sortBy=submissions
https://practice.geeksforgeeks.org/problems/count-the-reversals0401/1/?page=1&difficulty[]=1&category[]=Stack&sortBy=submissions
https://practice.geeksforgeeks.org/problems/87f12e5c728d69a5322634776b54c75897d14daa/1/?page=2&difficulty[]=1&category[]=Linked%20List&sortBy=submissions
https://practice.geeksforgeeks.org/problems/length-of-longest-palindrome-in-linked-list/1/?page=1&difficulty[]=1&category[]=Linked%20List&sortBy=submissions
https://practice.geeksforgeeks.org/problems/reorder-list/1/?page=1&difficulty[]=2&category[]=Linked%20List&sortBy=submissions
https://www.geeksforgeeks.org/union-and-intersection-of-two-linked-lists/



dp
https://www.geeksforgeeks.org/coin-change-dp-7/
https://www.geeksforgeeks.org/subset-sum-problem-dp-25/
https://www.google.com/search?q=unique+path&sxsrf=ALiCzsb3MdGPGeU-o08vuWdNXGAJhJ6bFQ%3A1653070558069&ei=3tqHYpfwA5nihwOjjIXYAw&ved=0ahUKEwiX15vb1-73AhUZ8WEKHSNGATsQ4dUDCA4&uact=5&oq=unique+path&gs_lcp=Cgdnd3Mtd2l6EANKBAhBGABKBAhGGABQAFgAYI8CaABwAXgAgAEAiAEAkgEAmAEAoAEBwAEB&sclient=gws-wiz
https://www.geeksforgeeks.org/unique-paths-in-a-grid-with-obstacles/
https://www.google.com/search?q=longest+common+subsequence&oq=longest+common+subsequence&aqs=chrome..69i57j35i39j0i512l5j69i60.11163j0j7&sourceid=chrome&ie=UTF-8
https://www.google.com/search?q=minimum+number+of+days+to+make+m+bouquets&oq=minimum+number+of+days+to+make+m+bouquets&aqs=chrome..69i57.2644j0j7&sourceid=chrome&ie=UTF-8
https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/
https://www.google.com/search?q=remve+the+node+in+linked+list+whose+sum+equals+0+using+stack&sxsrf=ALiCzsadrfvSWwFa0cuwFPKLUTPNxRgDSQ%3A1653076153059&ei=ufCHYuWqA8qfseMPvoiGmAM&ved=0ahUKEwil647H7O73AhXKT2wGHT6EATMQ4dUDCA4&uact=5&oq=remve+the+node+in+linked+list+whose+sum+equals+0+using+stack&gs_lcp=Cgdnd3Mtd2l6EAM6BwgAEEcQsAM6BwghEAoQoAE6CAghEB4QFhAdOgQIIRAVSgQIQRgASgQIRhgAUL4KWL4wYKQzaAFwAXgAgAGBBIgBuhySAQkyLTguMi4xLjGYAQCgAQHIAQjAAQE&sclient=gws-wiz
enerate all combination of array using stack 
https://www.google.com/search?q=remve+the+node+in+linked+list+whose+sum+equals+0+using+stack&sxsrf=ALiCzsadrfvSWwFa0cuwFPKLUTPNxRgDSQ%3A1653076153059&ei=ufCHYuWqA8qfseMPvoiGmAM&ved=0ahUKEwil647H7O73AhXKT2wGHT6EATMQ4dUDCA4&uact=5&oq=remve+the+node+in+linked+list+whose+sum+equals+0+using+stack&gs_lcp=Cgdnd3Mtd2l6EAM6BwgAEEcQsAM6BwghEAoQoAE6CAghEB4QFhAdOgQIIRAVSgQIQRgASgQIRhgAUL4KWL4wYKQzaAFwAXgAgAGBBIgBuhySAQkyLTguMi4xLjGYAQCgAQHIAQjAAQE&sclient=gws-wiz

https://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/
https://www.geeksforgeeks.org/counting-inversions/
Kth Smallest Difference

closest buddy
http://www.java2s.com/Code/Java/Development-Class/Getsthegreatestcommondivisoroftheabsolutevalueoftwonumbers.htm
https://www.geeksforgeeks.org/maximum-absolute-difference-value-index-sums/


https://learning.edx.org/course/course-v1:UQx+IELTSx+1T2020/block-v1:UQx+IELTSx+1T2020+type@sequential+block@7c9698f099f64652b8a55
d0d31475902/block-v1:UQx+IELTSx+1T2020+type@vertical+block@66f6b2c5ccfc4557b805b2092dd26f54

tips on:
import java.io.*; // for handling input/output
import java.util.*; /stack
import java.util.Map.Entry;

ery very important
https://docs.google.com/spreadsheets/d/1zvCoeo80JRwOjH00REgzmg0MxKq-dDp2B-OriZyrQgI/edit#gid=1786781222

https://leetcode.com/problems/word-ladder-ii/


LinkedList<Integer> arr=new LinkedList<Integer>();  
arr.add()  //It is used to append the specified element to the end of a list.
arr.add(int index, E element)
arr.addFirst(E e)
arr.addLast(E e)
arr.remove() //It is used to retrieve and removes the first element of a list.
arr.remove(Object o)  //It is used to remove the first occurrence of the specified element in a list.
arr.remove(int index)
arr.removeFirst()
arr.removeLast()
arr.size()

STACK
Stack<Integer> STACK = new Stack<Integer>();
stk.clear()
stk.push(0)
stk.peek()
stack.pop()
stack.clear();
stack.search(element);
stack.peek() //throws null pointer exception if stack is empty 
stack.empty()
stk.size()


Dequeue
Deque<String> deque= new LinkedList<String>();
deque.addFirst()
deque.addLast()
deque.peekFirst()
deque.peekLast()
deque.contains()
deque.removeFirst()
deque.removeLast()
deque.size()

https://www.geeksforgeeks.org/find-maximum-meetings-in-one-room/
https://leetcode.com/problems/find-and-replace-pattern/
https://leetcode.com/problems/maximum-score-words-formed-by-letters/
https://leetcode.com/problems/search-insert-position/

BufferedReader br= new BufferedReader(new InputStreamReader(System.in));
String[] arr=br.readLine().split(" ");
int abc=Integer.parseInt(br.readLine());

Scanner input=new Scanner(System.in);
String[] arr=input.nextLine().split("");
int abc=Integer.parseInt(input.nextLine());
int abcd=input.nextInt();		//nextFloat() , next() [string]

StringBuilder str = new StringBuilder();
str.delete(0, 7) //delete the substring
str.deleteCharAt(10);
str.insert(0, "  ");
str.toString()
str.substring(5)  // get substring start from index 5
str.substring(5, 8)j
str.append("");
str.reverse.toString();
str.replace(start, end, " ");  // upto end-1
sb.setLength(0);  // clear
str.setCharAt(2, 'S');

ArrayList<Integer> arr=new ArrayList<Integer>();
arr.add(val);
arr.add(index,val);
arr.set(index,val);
arr.clear();
arr.contains(val);
arr.get(index);
arr.indexOf(val);
arr.remove(index);
arr.remove(val);
arr.size();

HashSet<String> set = new HashSet<String>();
set.add(element)
set.contains(element)
set.remove(element)
set.size()


STRING 
char[] a={'a','b'}
String string1 = new String(a);
String string2 = new String("abc");
string2.toString();
String s = "GeeksforGeeks";
char[] gfg = s.toCharArray();
s.toUpperCase()
s.toLowerCase()
s = s.replaceAll(" ", "");
String[] arr2=s.split("");

Arrays.toString(a)



FOR ALPHANUMERIC MULTIPLE DELIMITER for valid gmail
String[] arr=s.split("[\\[\\]_#$%^&*!@?;.,`():\\-'{}\"\\s]+");


LIBRARY
Collections.min(arr)
max = Math.max(max, arr[i]);
Arrays.sort(arr)
Arrays.sort(a, Collections.reverseOrder());  
Collections.sort(arraylist, Collections.reverseOrder())
ArrayList<ArrayList<Integer>>aList=new ArrayList<ArrayList<Integer>>();
List<List<String>> aList = new ArrayList<>();
Arrays.binarySearch(arr,Key))
Arrays.sort(arr)


ArrayList<ArrayList<Integer>> arr=new ArrayList<>();
ArrayList<Integer> a1=new ArrayList<Integer>();
a1.add(23);
a1.add(45);
//arr.add(a1)
arr.add(new ArrayList<Integer>(a1));
for(ArrayList<Integer> temp:arr){
 System.out.println(temp); 
}


static long gcd(long a, long b)
{
    if (b == 0)
    return a;
    return gcd(b, a % b);
}

static  int factorial(int n)
{
    // single line to find factorial
    return (n == 1 || n == 0) ? 1 : n * factorial(n - 1);  
}

static long printNcR(long n, long r)
{
    // p holds the value of n*(n-1)*(n-2)..., // k holds the value of r*(r-1)...
    long p = 1, k = 1;
    // C(n, r) == C(n, n-r),    // choosing the smaller value
    if (n - r < r) {
        r = n - r;
    }
    if (r != 0) {
        while (r > 0) {
            p *= n;
            k *= r;
            // gcd of p, k
            long m = gcd(p, k);
            // dividing by gcd, to simplify   // product division by their gcd // saves from the overflow
            p /= m;
            k /= m;
            n--;
            r--;
        }
    }
    else {
        p = 1;
    }
    return p;
    // if our approach is correct p = ans and k =1    // System.out.println(p);
}



MODULAR INVERSE
			int a=input.nextInt();
			int m=input.nextInt();
			int q,r1,r2,r,t1,t2,t;
			r1=m;
			r2=a;
			t1=0;
			t2=1;
			while(r2>0){
				q=r1/r2;
				r=r1%r2;
				t=t1-t2*q;
				r1=r2;
				r2=r;
				t1=t2;
				t2=t;
			}
			if(r1==1){
				int temp=t1>0?t1:(t1+m);
				System.out.println(temp);
			}else{
				System.out.println("-1");
			}			



IS PRIME

    public static boolean isPrime(int n){
        int sq = (int) Math.sqrt(n);
        for(int j =2;j<=sq;j++){
            if(n%j==0){
                return false;
            }
        }
        return true;
    } 	
   
COUNT ALL PRIMES LESS THAN N
int count=0;
        
boolean[] arr=new boolean[n];
        
for(int i=2;i<n;i++){
            
	if(arr[i]==false){
                
	count++;
                
	for(int j=i;j<n;j+=i){
                    
	arr[j]=true;
                
	}
            
	}
        
}


USING COMPARATOR 

        HashMap<Integer, Integer> temp = new LinkedHashMap<Integer, Integer>();
        for (Map.Entry<Integer, Integer> aa : list.entrySet()) {
            temp.put(aa.getKey(), aa.getValue());
        }

	//hm.put(i,hm.getOrDefault(i,0)+1);

	/**
        for(Integer k:s.keySet()){       
                 System.out.print(k+" "+s.get(k)+" ");
        }
	**/

	/**
	for ( Map.Entry<String, Tab> entry : hash.entrySet()) {
	System.out.println(entry.getkey()+" "+entry.getValue());
	}
	**/

	/**
        for(Integer val:hash.values()){
		System.out.println(val);
        }
	**/


	class SortbykeyValue implements Comparator<Entry<Integer, Integer>> {
    		public int compare(Entry<Integer, Integer> o1, Entry<Integer, Integer> o2)
    		{
        		return o2.getValue().compareTo(o1.getValue());
    		}
	}

        ArrayList<Map.Entry<Integer,Integer>>list = new ArrayList<Map.Entry<Integer,Integer>>(m.entrySet());
        Collections.sort(list, new SortbykeyValue());
	
OR

    List<Map.Entry<Integer,Integer>> lis=new ArrayList<>(mp.entrySet());
    
    lis.sort((a,b)->b.getValue().compareTo(a.getValue()));

        for(Map.Entry<Integer,Integer> a:list){
            for(int j=0;j<a.getValue();j++){
            System.out.print(a.getKey()+" ");
            }            
        }



			class Sortbyroll implements Comparator<Student> {
				// Used for sorting in ascending order of
				// roll number
				public int compare(Student a, Student b)
				{
				return a.rollno - b.rollno;
				}
			}

		Student[] arr
			= { new Student(111, "bbbb", "london"),
				new Student(131, "aaaa", "nyc"),
				new Student(121, "cccc", "jaipur") };

			Arrays.sort(arr, new Sortbyroll());


To maintain the insertion order while retrieving the  hashmap use linkedhashmap
HashMap<String, String> hm = new LinkedHashMap<>();


LENGTH OF LONGEST SUBSTRING UNIQUE CHARACTER

    public int lengthOfLongestSubstring(String s) {
        StringBuilder s1=new StringBuilder();
        int max=0;
        for(int i=0;i<s.length();i++){
            HashSet<Character> h=new HashSet<>();
            for(int j=i;j<s.length();j++){
                // System.out.print(h+" "+s.charAt(j));
                if(!h.contains(s.charAt(j))){
                    h.add(s.charAt(j));
                    if(max<h.size()){
                    	// String result = String.join("",h.toString());
                    	// System.out.println("\n"+result +" "+max);
                    	// System.out.println();
                    	// s1=new StringBuilder(result);  
                        max=h.size();
                    }
                }else{
                    break;
                }  
            }
        }
        System.out.print(s1);
        return max;
    }




MODULATR EXPONENTIATION
b^c% mod 
			long res = 1L;
			while(c!=0){
				if ((c & 1) == 1) {
                		  res = (res * b) % (mod);
				}
				b=(b*b)%(mod);
				c=c>>1;
			}


REVERSING

while(start<end){
            temp=nums[start];
            nums[start]=nums[end];
            nums[end]=temp;
            start++;
            end--;
        }

// Java implementation of simple method to find count of pairs with given sum.
// Returns number of pairs in arr[0..n-1] with sum equal to 'sum'
static int getPairsCount(int arr[], int n, int k)
{
    HashMap<Integer,Integer> m = new HashMap<>();
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (m.containsKey(k - arr[i])) {
            count += m.get(k - arr[i]);
        }
	/**
	pair sum divisble by k
        if (map.containsKey(Math.abs(k - (arr[i] % k))%k)) {
            count += map.get(Math.abs(k - (arr[i] % k))%k);
        }
            if(map.containsKey(arr[i] % k)){
                map.put(arr[i] % k, map.get(arr[i] % k)+1);
            }
            else{
                map.put(arr[i] % k, 1);
            }
	**/
        if(m.containsKey(arr[i])){
            m.put(arr[i], m.get(arr[i])+1);
        }
        else{
            m.put(arr[i], 1);
        }
    }
    return count;
}


PERMUTATION OF ARRAY ELEMENTS
    private void permute(String str, int l, int r)
    {
        if (l == r)
            System.out.println(str);
        else
        {
            for (int i = l; i <= r; i++)
            {
                str = swap(str,l,i);
                permute(str, l+1, r);
                str = swap(str,l,i);
            }
        }
    }


LONGEST SUBARRAY EQUAlS TO SUM K and print all subarrays sum equals K

    // function to find the length of longest // subarray having sum k
    static int lenOfLongSubarr(int[] arr, int n, int k)
    {
        // HashMap to store (sum, index) tuples
        HashMap<Integer, Integer> map = new HashMap<>();
        int sum = 0, maxLen = 0;
        int startindex=0;
        int endindex=0;
        for (int i = 0; i < n; i++) {
            // accumulate sum
            sum += arr[i];
            // when subarray starts from index '0'
            if (sum == k){
                maxLen = i + 1;
                endindex=i;
                for(int ii=startindex;ii<=endindex;ii++){
                    System.out.print(arr[ii]+" ");
                }
                System.out.println();
            }
            // make an entry for 'sum' if it is // not present in 'map'
            if (!map.containsKey(sum)) {
                map.put(sum, i);
            }
            // check if 'sum-k' is present in 'map' // or not
            if (map.containsKey(sum - k)) {
                // update maxLength
                if (maxLen < (i - map.get(sum - k))){
                    maxLen = i - map.get(sum - k);}
                startindex=map.get(sum - k)+1;
                endindex=i;
                for(int ii=startindex;ii<=endindex;ii++){
                    System.out.print(arr[ii]+" ");
                }
                System.out.println();
            }
        }
        return maxLen;
    }



LONGEST COMMON PREFIX
 
alternate method
    //arrays of string
    public String longestCommonPrefix(String[] a)
    {
        int size = a.length;
        if (size == 0)
            return "";
        if (size == 1)
            return a[0];
        Arrays.sort(a);
        int end = Math.min(a[0].length(), a[size-1].length());
        int i = 0;
        while (i < end && a[0].charAt(i) == a[size-1].charAt(i) )
            i++;
        String pre = a[0].substring(0, i);
        return pre;
    }


SEARCH FOR ELEMENT IN SORTED ROTATED ARRAY

    private static int search(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
        while (low <= high) { 
            int mid = (low + high) >> 1; 
            if (arr[mid] == target)
                return mid; 
            if (arr[low] <= arr[mid]) { 
                if (arr[low] <= target && arr[mid] >= target)
                    high = mid - 1; 
                else
                    low = mid + 1; 
            } else { 
                if (arr[mid] <= target && target <= arr[high])
                    low = mid + 1;
                else
                    high = mid - 1;
            }
        }
        return -1;
    }

RECURSIVE PROGRAM TO FIND POWER(A,N)

static int power(int x, int y) 
{ 
    int temp; 
    if( y == 0) 
        return 1; 
    temp = power(x, y / 2); 
    if (y % 2 == 0) 
        return temp*temp; 
    else
        return x*temp*temp; 
} 
  

PRINT IN SPRIAL ORDER OF MATRIX

    public List<Integer> spiralOrder(int[][] matrix) {
        int len=matrix.length;
        int row1=0;
        int row2=len-1;
        int col1=0;
        int col2=matrix[0].length-1;

        List<Integer> arr=new ArrayList<Integer>();
        while(arr.size()<(len*matrix[0].length)){

            for(int i=col1;i<=col2;i++){
                System.out.print(matrix[row1][i]);
                arr.add(matrix[row1][i]);
            }
            for(int i=row1;i<=row2;i++){
                if(i!=row1){
                   System.out.print(matrix[i][col2]); 
                    arr.add(matrix[i][col2]);
                }
            }      
            for(int i=col2;i>=col1;i--){
                if(i!=col2 && row1!=row2){
                    System.out.print(matrix[row2][i]);
                    arr.add(matrix[row2][i]);
                } 
            }
            for(int i=row2;i>row1;i--){
                if(i!=row2 && col1!=col2){
                   System.out.print(matrix[i][col1]); 
                    arr.add(matrix[i][col1]);
                }
            }
            row1++;
            row2--;
            col1++;
            col2--;
            
        }
        return arr;
    }



Longest  consecutive sub sequence

    static int findLongestConseqSubseq(int arr[], int N)
    {
 
        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
        for (int i = 0; i < N; i++)
        {
            pq.add(arr[i]);
        }
        int prev = pq.poll();
        int c = 1;
        int max = 1;
        for (int i = 1; i < N; i++)
        {
            if (pq.peek() - prev > 1)
            {
                c = 1;
                prev = pq.poll();
            }
            else if (pq.peek() - prev == 0)
            {
                prev = pq.poll();
            }
            else
            {
                c++;
                prev = pq.poll();
            }
            if (max < c)
            {
                max = c;
            }
        }
        return max;
    }



rotation of array


    public void rotate(int[] nums, int k) {
        //Rotation of array right by k
        k=k%nums.length;
	n=nums.length;
	// right rotation , clockwise
        reverse(nums,0,n-k-1);
        reverse(nums,n-k,n-1);
        reverse(nums,0,n-1);
        
        // for left rotation counter clockwise
        // reverse(nums,0,k-1);
        // reverse(nums,k,n-1);
        // reverse(nums,0,n-1);
    }

    public void reverse(int[] nums,int start,int end){
        int temp=0;
        while(start<end){
            temp=nums[start];
            nums[start]=nums[end];
            nums[end]=temp;
            start++;
            end--;
        }
    }


container in most water

    public int maxArea(int[] height) {
        int result=0;
        int i,j,max=0,min_h;
        i=0;
        j=height.length-1;
        while(i<j){
            min_h=height[i]>height[j]?height[j]:height[i];
            max=Math.max(max,(j-i)*min_h);
            if(height[i]<height[j]){
                i++;
            }else{
                j--;
            }
        }
        return max;
    }


generate all combination of balanced paranthesis

    public static void generateParenthesis(int n, int open, int close,String s, ArrayList<String> ans)
    {
        if (open == n && close == n) {
            ans.add(s);
            return;
        }
        if (open < n) {
            generateParenthesis(n, open + 1, close, s + "{",ans);
        }
        if (close < open) {
            generateParenthesis(n, open, close + 1, s + "}",ans);
        }
    }

Largest sum contiguous subarray /FIND SUBARRAY WITH LARGEST SUM

    static void maxSubArraySum(int a[], int size)
    {
        int max_so_far = Integer.MIN_VALUE,
        max_ending_here = 0,start = 0,
        end = 0, s = 0;
        for (int i = 0; i < size; i++)
        {
            max_ending_here += a[i];
            if (max_so_far < max_ending_here)
            {
                max_so_far = max_ending_here;
                start = s;
                end = i;
            }
            if (max_ending_here < 0)
            {
                max_ending_here = 0;
                s = i + 1;
            }
        }
        System.out.println("Maximum contiguous sum is "+ max_so_far);
        System.out.println("Starting index " + start);
        System.out.println("Ending index " + end);
    }

Lexicographic minimum  after circular rotation
// BCABDADAB
        String concat = str + str;

        for (int i = 0; i < n; i++)
        {
            arr[i] = concat.substring(i, i + n);
        }
 
        // Sort all rotations
        Arrays.sort(arr);	// ABBCABDAD


Find the closest pair from two sorted arrays

  public static int findpair(int[] arr1,int[] arr2,int x){
    int first,second;
    first=second=0;
    int diff=Integer.MAX_VALUE;
    int i,j;
    i=0;
    j=arr2.length-1;
    int temp;
    while(i<arr1.length && j>=0){
      temp=arr1[i]+arr2[j];
      if(Math.abs(x-temp)<diff){
        diff=Math.abs(x-temp);
        first=arr1[i];
        second=arr2[j];
      }
      if(temp>x){
        j--;
      }else{
      	i++;
      }   
    }
    System.out.println(first+" "+second);
    return diff;
  }


 maximum length palindrome substring 

    static String manachersAlgorithm(String s, int N) {
        String str1 = convertToNewString(s);
        char[] str=str1.toCharArray();
        int len = (2 * N) + 1;
        int[] P = new int[100000];
        int c = 0; //stores the center of the longest palindromic substring until now
        int r = 0; //stores the right boundary of the longest palindromic substring until now
        for (int i = 1; i < str.length - 1; i++) {
            // find the corresponding letter in the palidrome subString
            int iMirror = c - (i - c);
            if(r > i) {
                P[i] = Math.min(r - i, P[iMirror]);
            }
            // expanding around center i
            while (str[i + 1 + P[i]] == str[i - 1 - P[i]]){
                P[i]++;
            }
            // Update c,r in case if the palindrome centered at i expands past r
            if (i + P[i] > r) {
                c = i;              // next center = i
                r = i + P[i];
            }
        }

        int maxPalindrome = 0;
        int centerIndex = 0;

        for (int i = 1; i < (str.length - 1); i++) {
            if (P[i] > maxPalindrome) {
                maxPalindrome = P[i];
                centerIndex = i;
            }
        }

        System.out.println("max length "+maxPalindrome);
        return s.substring( (centerIndex - 1 - maxPalindrome) / 2, (centerIndex - 1 - maxPalindrome) /2 + maxPalindrome);
    }


    static String convertToNewString( String s) {
        String newString = "@";
        for (int i = 0; i < s.length(); i++) {
            newString += "#" + s.substring(i, i+1);
        }
        newString += "#$";
        return newString;
    }


repeating character least index from start
Word Break Problem
Sort all even numbers in ascending order and then sort all odd numbers in descending order
find-a-repeating-and-a-missing-number
equilibrium point in array
Find the Missing Number
maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix
Given an n x n square matrix, find sum of all sub-squares of size k x k
Find maximum depth of nested parenthesis in a string
Split a Circular Linked List into three halves of almost same size

to understand once again
https://www.geeksforgeeks.org/maximum-sum-rectangle-in-a-2d-matrix-dp-27/


First negative integer in every window of size k
static void printFirstNegativeInteger(int arr[],int k, int n)
{
    int firstNegativeIndex = 0;
    int firstNegativeElement;
    for(int i = k - 1; i < n; i++)
    {
        while ((firstNegativeIndex < i ) &&(firstNegativeIndex <= i - k ||arr[firstNegativeIndex] >= 0))
        {
            firstNegativeIndex ++;
        }
        if (arr[firstNegativeIndex] < 0)
        {
            firstNegativeElement = arr[firstNegativeIndex];
        }
        else
        {
            firstNegativeElement = 0;
        }
        System.out.print(firstNegativeElement + " ");
    }
}



kth smallest absolute difference in the array

    // returns number of pairs with absolute
    // difference less than or equal to mid 
    static int countPairs(int[] a, int n, int mid)
    {
        int res = 0, value;
        for(int i = 0; i < n; i++)
        {
            // Upper bound returns pointer to position
            // of next higher number than a[i]+mid in
            // a[i..n-1]. We subtract (ub + i + 1) from
            // this position to count 
            if(a[i]+mid>a[n-1])
              res+=(n-(i+1));
            else
            {
             int ub = upperbound(a, n, a[i]+mid);
             res += (ub- (i+1));
            }
        }
        return res;
    }
  
    // returns the upper bound
    static int upperbound(int a[], int n, int value)
    {
        int low = 0;
        int high = n;
        while(low < high)
        {
            final int mid = (low + high)/2;
            if(value >= a[mid])
                low = mid + 1;
            else
                high = mid;
        }
  
    return low;
    }
  
    // Returns k-th absolute difference
    static int kthDiff(int a[], int n, int k)
    {
        // Sort array
        Arrays.sort(a);
  
        // Minimum absolute difference
        int low = a[1] - a[0];
        for (int i = 1; i <= n-2; ++i)
            low = Math.min(low, a[i+1] - a[i]);
  
        // Maximum absolute difference
        int high = a[n-1] - a[0];
  
        // Do binary search for k-th absolute difference
        while (low < high)
        {
            int mid = (low + high) >> 1;
            if (countPairs(a, n, mid) < k)
                low = mid + 1;
            else
                high = mid;
        }
  
        return low;
    }


Least greater element on right

    public static void replace(int[] nums)
    {
        for (int i = 0; i < nums.length; i++)
        {
            int successor = -1;
            int diff = Integer.MAX_VALUE;
            for (int j = i + 1; j < nums.length; j++)
            {
                if (nums[j] > nums[i] && (nums[j] - nums[i] < diff))
                {
                    successor = nums[j];
                    diff = nums[j] - nums[i];
                }
            }
            nums[i] = successor;
        }
        System.out.println(Arrays.toString(nums));
    }


number-subarrays-sum-exactly-equal-k

    static int findSubarraySum(int arr[], int n, int sum)
    {
        HashMap<Integer, Integer> prevSum = new HashMap<>();
        prevSum.put(0,1);
        int res = 0;
        int currsum = 0;
 
        for (int i = 0; i < n; i++) {
            currsum += arr[i];
            int removeSum=currSum-sum;
            if (prevSum.containsKey(removeSum))
                res += prevSum.get(removeSum);
            prevSum.put(currSum,prevSum.getOrDefault(currSum,0)+1);
        }
        return res;
    }

